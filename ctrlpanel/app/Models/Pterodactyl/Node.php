<?php

namespace App\Models\Pterodactyl;

use App\Classes\PterodactylClient;
use Exception;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use App\Models\Product;

class Node extends Model
{
    use HasFactory;

    public $incrementing = false;

    public $guarded = [];

    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        static::deleting(function (Node $node) {
            $node->products()->detach();
        });
    }

    /**
     * @throws Exception
     */
    public static function syncNodes()
    {
        Location::syncLocations();
        $client = app(PterodactylClient::class);
        $nodes = $client->getNodes();

        //map response
        $nodes = array_map(function ($node) {
            return [
                'id' => $node['attributes']['id'],
                'location_id' => $node['attributes']['location_id'],
                'name' => $node['attributes']['name'],
                'description' => $node['attributes']['description'],
            ];
        }, $nodes);

        //update or create with resource caching
        foreach ($nodes as $node) {
            // Get detailed node info with resources
            $nodeDetails = $client->getNode($node['id']);
            
            self::query()->updateOrCreate(
                [
                    'id' => $node['id'],
                ],
                [
                    'name' => $node['name'],
                    'description' => $node['description'],
                    'location_id' => $node['location_id'],
                    'disabled' => false,
                    'memory' => $nodeDetails['memory'],
                    'disk' => $nodeDetails['disk'],
                    'memory_overallocate' => $nodeDetails['memory_overallocate'],
                    'disk_overallocate' => $nodeDetails['disk_overallocate'],
                    'allocated_resources' => json_encode($nodeDetails['allocated_resources']),
                    'resource_updated_at' => now(),
                ]);
        }

        self::removeDeletedNodes($nodes);
    }

    /**
     * @description remove nodes that have been deleted on pterodactyl
     *
     * @param  array  $nodes
     */
    private static function removeDeletedNodes(array $nodes): void
    {
        $ids = array_map(function ($data) {
            return $data['id'];
        }, $nodes);

        self::all()->each(function (Node $node) use ($ids) {
            if (! in_array($node->id, $ids)) {
                $node->delete();
            }
        });
    }

    /**
     * @return BelongsTo
     */
    public function location(): BelongsTo
    {
        return $this->belongsTo(Location::class);
    }

    /**
     * @return BelongsToMany
     */
    public function products()
    {
        return $this->belongsToMany(Product::class, 'node_product', 'node_id', 'product_id');
    }

    /**
     * Check if node has enough resources for the given requirements (using cached data)
     * 
     * @param int $requireMemory
     * @param int $requireDisk
     * @return bool
     */
    public function hasAvailableResources(int $requireMemory, int $requireDisk): bool
    {
        if (!$this->memory || !$this->disk || !$this->allocated_resources) {
            return false; // Если нет кешированных данных, считаем что ресурсов нет
        }

        $allocatedResources = json_decode($this->allocated_resources, true);
        
        $maxMemory = ($this->memory * ($this->memory_overallocate + 100) / 100);
        $maxDisk = ($this->disk * ($this->disk_overallocate + 100) / 100);
        
        $availableMemory = $maxMemory - $allocatedResources['memory'];
        $availableDisk = $maxDisk - $allocatedResources['disk'];
        
        return $requireMemory <= $availableMemory && $requireDisk <= $availableDisk;
    }

    /**
     * Get available memory on this node
     * 
     * @return int
     */
    public function getAvailableMemory(): int
    {
        if (!$this->memory || !$this->allocated_resources) {
            return 0;
        }

        $allocatedResources = json_decode($this->allocated_resources, true);
        $maxMemory = ($this->memory * ($this->memory_overallocate + 100) / 100);
        
        return max(0, $maxMemory - $allocatedResources['memory']);
    }

    /**
     * Get available disk on this node
     * 
     * @return int
     */
    public function getAvailableDisk(): int
    {
        if (!$this->disk || !$this->allocated_resources) {
            return 0;
        }

        $allocatedResources = json_decode($this->allocated_resources, true);
        $maxDisk = ($this->disk * ($this->disk_overallocate + 100) / 100);
        
        return max(0, $maxDisk - $allocatedResources['disk']);
    }

    /**
     * Get node usage percentage
     * 
     * @return float
     */
    public function getUsagePercent(): float
    {
        if (!$this->memory || !$this->disk || !$this->allocated_resources) {
            return 0.0;
        }

        $allocatedResources = json_decode($this->allocated_resources, true);
        
        $memoryUsage = $allocatedResources['memory'] / ($this->memory * ($this->memory_overallocate + 100) / 100);
        $diskUsage = $allocatedResources['disk'] / ($this->disk * ($this->disk_overallocate + 100) / 100);
        
        return round(max($memoryUsage, $diskUsage) * 100, 2);
    }
}
