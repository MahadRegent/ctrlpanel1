<?php

namespace App\Http\Controllers;

use App\Models\Pterodactyl\Egg;
use App\Models\Pterodactyl\Location;
use App\Models\Pterodactyl\Nest;
use App\Models\Pterodactyl\Node;
use App\Models\Product;
use App\Models\Server;
use App\Models\User;
use App\Notifications\ServerCreationError;
use App\Settings\DiscordSettings;
use Carbon\Carbon;
use App\Settings\UserSettings;
use App\Settings\ServerSettings;
use App\Settings\PterodactylSettings;
use App\Classes\PterodactylClient;
use App\Settings\GeneralSettings;
use Exception;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Http\Client\Response;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Request as FacadesRequest;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class ServerController extends Controller
{
    private const CREATE_PERMISSION = 'user.server.create';
    private const UPGRADE_PERMISSION = 'user.server.upgrade';
    private const BILLING_PERIODS = [
        'hourly' => 3600,
        'daily' => 86400,
        'weekly' => 604800,
        'monthly' => 2592000,
        'quarterly' => 7776000,
        'half-annually' => 15552000,
        'annually' => 31104000
    ];

    // Агрессивное кеширование для статических данных
    private const CACHE_TTL = 300; // 5 минут
    private const STATIC_CACHE_TTL = 3600; // 1 час для статических данных
    private const SERVER_INFO_CACHE_PREFIX = 'server_info_';
    private const USER_SERVERS_CACHE_PREFIX = 'user_servers_';

    private PterodactylClient $pterodactyl;
    private PterodactylSettings $pteroSettings;
    private GeneralSettings $generalSettings;
    private ServerSettings $serverSettings;
    private UserSettings $userSettings;
    private DiscordSettings $discordSettings;

    public function __construct(
        PterodactylSettings $pteroSettings,
        GeneralSettings $generalSettings,
        ServerSettings $serverSettings,
        UserSettings $userSettings,
        DiscordSettings $discordSettings
    ) {
        $this->pteroSettings = $pteroSettings;
        $this->pterodactyl = new PterodactylClient($pteroSettings);
        $this->generalSettings = $generalSettings;
        $this->serverSettings = $serverSettings;
        $this->userSettings = $userSettings;
        $this->discordSettings = $discordSettings;
    }

    public function index(): \Illuminate\View\View
    {
        $servers = $this->getServersWithInfoCached();

        return view('servers.index')->with([
            'servers' => $servers,
            'credits_display_name' => $this->generalSettings->credits_display_name,
            'pterodactyl_url' => $this->pteroSettings->panel_url,
            'phpmyadmin_url' => $this->generalSettings->phpmyadmin_url
        ]);
    }

    public function create(): \Illuminate\View\View|RedirectResponse
    {
        $this->checkPermission(self::CREATE_PERMISSION);

        $validationResult = $this->validateServerCreation(app(Request::class));
        if ($validationResult) {
            return $validationResult;
        }

        // РАДИКАЛЬНАЯ ОПТИМИЗАЦИЯ - кешируем все данные на 1 час
        $createData = Cache::remember('server_create_data_v2', self::STATIC_CACHE_TTL, function () {
            // Убираем сложные запросы, делаем простые с индексами
            return [
                'productCount' => DB::table('products')->where('disabled', false)->count(),
                'nodeCount' => DB::table('nodes')->count(),
                'nests' => $this->getCachedNests(),
                'locations' => $this->getCachedLocations(),
                'eggs' => $this->getCachedEggs(),
                'products' => $this->getCachedProducts(), // Добавляем продукты сразу
            ];
        });

        return view('servers.create')->with(array_merge($createData, [
            'user' => Auth::user(),
            'server_creation_enabled' => $this->serverSettings->creation_enabled,
            'min_credits_to_make_server' => $this->userSettings->min_credits_to_make_server,
            'credits_display_name' => $this->generalSettings->credits_display_name,
            'location_description_enabled' => $this->serverSettings->location_description_enabled,
            'store_enabled' => $this->generalSettings->store_enabled
        ]));
    }

    // ОПТИМИЗИРОВАННЫЕ МЕТОДЫ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ
    private function getCachedNests()
    {
        return Cache::remember('nests_optimized', self::STATIC_CACHE_TTL, function () {
            return DB::table('nests')
                ->select('id', 'name', 'description')
                ->get();
        });
    }

    private function getCachedLocations()
    {
        return Cache::remember('locations_optimized', self::STATIC_CACHE_TTL, function () {
            return DB::table('locations')
                ->select('id', 'short', 'long')
                ->get();
        });
    }

    private function getCachedEggs()
    {
        return Cache::remember('eggs_optimized', self::STATIC_CACHE_TTL, function () {
            return DB::table('eggs')
                ->join('egg_product', 'eggs.id', '=', 'egg_product.egg_id')
                ->join('products', 'egg_product.product_id', '=', 'products.id')
                ->where('products.disabled', false)
                ->select('eggs.id', 'eggs.name', 'eggs.nest_id')
                ->distinct()
                ->get();
        });
    }

    private function getCachedProducts()
    {
        return Cache::remember('products_optimized', self::STATIC_CACHE_TTL, function () {
            return DB::table('products')
                ->leftJoin('node_product', 'products.id', '=', 'node_product.product_id')
                ->leftJoin('nodes', 'node_product.node_id', '=', 'nodes.id')
                ->leftJoin('egg_product', 'products.id', '=', 'egg_product.product_id')
                ->where('products.disabled', false)
                ->select(
                    'products.*',
                    DB::raw('GROUP_CONCAT(DISTINCT nodes.location_id) as location_ids'),
                    DB::raw('GROUP_CONCAT(DISTINCT egg_product.egg_id) as egg_ids')
                )
                ->groupBy('products.id')
                ->get()
                ->map(function ($product) {
                    $product->location_ids = $product->location_ids ? explode(',', $product->location_ids) : [];
                    $product->egg_ids = $product->egg_ids ? explode(',', $product->egg_ids) : [];
                    return $product;
                });
        });
    }

    public function store(Request $request): RedirectResponse
    {
        $validationResult = $this->validateServerCreation($request);
        if ($validationResult) return $validationResult;

        $request->validate([
            'name' => 'required|max:191',
            'location' => 'required|exists:locations,id',
            'egg' => 'required|exists:eggs,id',
            'product' => 'required|exists:products,id',
            'egg_variables' => 'nullable|string'
        ]);

        $server = $this->createServer($request);

        if (!$server) {
            return redirect()->route('servers.index')
                ->with('error', __('Server creation failed'));
        }

        $this->handlePostCreation($request->user(), $server);

        // Очищаем кеш пользователя после создания
        $this->clearUserCache($request->user()->id);

        return redirect()->route('servers.index')
            ->with('success', __('Server created'));
    }

    private function validateServerCreation(Request $request): ?RedirectResponse
    {
        $user = Auth::user();

        if ($user->servers()->count() >= $user->server_limit) {
            return redirect()->route('servers.index')
                ->with('error', __('Server limit reached!'));
        }

        if ($request->has('product')) {
            $product = Product::findOrFail($request->input('product'));
            $location = $request->input('location');

            $validationResult = $this->validateProductRequirements($product, $request);
            if ($validationResult !== true) {
                return redirect()->route('servers.index')
                    ->with('error', $validationResult);
            }
        }

        if (!$this->validateUserRequirements()) {
            return redirect()->route('profile.index')
                ->with('error', __('User requirements not met'));
        }

        return null;
    }

    private function validateProductRequirements(Product $product, Request $request): string|bool
    {
        $location = $request->input('location');
        $availableNode = $this->findAvailableNode($location, $product);

        if (!$availableNode) {
            return __("The chosen location doesn't have the required memory or disk left to allocate this product.");
        }

        $user = Auth::user();
        
        // ОПТИМИЗИРУЕМ ЗАПРОС ПОДСЧЕТА
        $productCount = Cache::remember("user_{$user->id}_product_{$product->id}_count", 60, function () use ($user, $product) {
            return DB::table('servers')
                ->where('user_id', $user->id)
                ->where('product_id', $product->id)
                ->whereNull('deleted_at')
                ->count();
        });

        if ($productCount >= $product->serverlimit && $product->serverlimit != 0) {
            return __('You can not create any more Servers with this product!');
        }

        $minCredits = $product->minimum_credits == -1
            ? $this->userSettings->min_credits_to_make_server
            : $product->minimum_credits;

        if ($user->credits < $minCredits) {
            return 'You do not have the required amount of ' . $this->generalSettings->credits_display_name . ' to use this product!';
        }

        // ИСПРАВЛЕНИЕ: Проверяем, хватает ли средств на покупку продукта
        if ($user->credits < $product->price) {
            return 'Insufficient ' . $this->generalSettings->credits_display_name . ' to purchase this product. You need ' . number_format($product->price, 2) . ' ' . $this->generalSettings->credits_display_name . ' but have only ' . number_format($user->credits, 2) . '.';
        }

        return true;
    }

    private function validateUserRequirements(): bool
    {
        $user = Auth::user();

        if ($this->userSettings->force_email_verification && !$user->hasVerifiedEmail()) {
            return false;
        }

        if (!$this->serverSettings->creation_enabled && $user->cannot("admin.servers.bypass_creation_enabled")) {
            return false;
        }

        if ($this->userSettings->force_discord_verification && !$user->discordUser) {
            return false;
        }

        return true;
    }

    // НОВЫЙ ОПТИМИЗИРОВАННЫЙ МЕТОД С ЛЕНИВОЙ ЗАГРУЗКОЙ
    private function getServersWithInfoCached(): \Illuminate\Database\Eloquent\Collection
    {
        $userId = Auth::id();
        $cacheKey = self::USER_SERVERS_CACHE_PREFIX . $userId;
        
        // Кешируем серверы пользователя с продуктами
        $servers = Cache::remember($cacheKey, self::CACHE_TTL, function () {
            return DB::table('servers')
                ->leftJoin('products', 'servers.product_id', '=', 'products.id')
                ->where('servers.user_id', Auth::id())
                ->whereNull('servers.deleted_at')
                ->select(
                    'servers.*',
                    'products.name as product_name',
                    'products.price as product_price',
                    'products.memory as product_memory',
                    'products.disk as product_disk'
                )
                ->get()
                ->map(function ($server) {
                    // Преобразуем в объект, похожий на Eloquent модель
                    $serverObj = (object) $server;
                    
                    // Добавляем кешированную информацию из БД если есть
                    if ($server->cached_location) {
                        $serverObj->location = $server->cached_location;
                        $serverObj->egg = $server->cached_egg;
                        $serverObj->nest = $server->cached_nest;
                        $serverObj->node = $server->cached_node;
                    } else {
                        // Только если нет кешированных данных, загружаем из API
                        $this->updateServerInfoFromApi($serverObj);
                    }
                    
                    return $serverObj;
                });
        });

        return collect($servers);
    }

    // МИНИМАЛЬНЫЕ API ЗАПРОСЫ
    private function updateServerInfoFromApi($server): void
    {
        if (!$server->pterodactyl_id) return;

        $cacheKey = self::SERVER_INFO_CACHE_PREFIX . $server->pterodactyl_id;
        
        $serverInfo = Cache::remember($cacheKey, self::CACHE_TTL, function () use ($server) {
            try {
                $info = $this->pterodactyl->getServerAttributes($server->pterodactyl_id);
                return $info ?: [];
            } catch (Exception $e) {
                Log::warning('Failed to get server info from API', [
                    'server_id' => $server->id,
                    'error' => $e->getMessage()
                ]);
                return [];
            }
        });

        if (empty($serverInfo)) {
            return;
        }

        $this->updateServerInfoInMemory($server, $serverInfo);
        
        // Асинхронно сохраняем в БД (не блокируем запрос)
        dispatch(function () use ($server, $serverInfo) {
            $this->saveServerInfoToDatabase($server, $serverInfo);
        })->afterResponse();
    }

    private function updateServerInfoInMemory($server, array $serverInfo): void
    {
        try {
            if (!isset($serverInfo['relationships'])) return;

            $relationships = $serverInfo['relationships'];
            $locationAttrs = $relationships['location']['attributes'] ?? [];
            $eggAttrs = $relationships['egg']['attributes'] ?? [];
            $nestAttrs = $relationships['nest']['attributes'] ?? [];
            $nodeAttrs = $relationships['node']['attributes'] ?? [];

            $server->location = $locationAttrs['long'] ?? $locationAttrs['short'] ?? null;
            $server->egg = $eggAttrs['name'] ?? null;
            $server->nest = $nestAttrs['name'] ?? null;
            $server->node = $nodeAttrs['name'] ?? null;
        } catch (Exception $e) {
            Log::warning('Failed to update server info in memory', [
                'server_id' => $server->id,
                'error' => $e->getMessage()
            ]);
        }
    }

    // АСИНХРОННОЕ СОХРАНЕНИЕ В БД
    private function saveServerInfoToDatabase($server, array $serverInfo): void
    {
        try {
            if (!isset($serverInfo['relationships'])) return;

            $relationships = $serverInfo['relationships'];
            $locationAttrs = $relationships['location']['attributes'] ?? [];
            $eggAttrs = $relationships['egg']['attributes'] ?? [];
            $nestAttrs = $relationships['nest']['attributes'] ?? [];
            $nodeAttrs = $relationships['node']['attributes'] ?? [];

            DB::table('servers')
                ->where('id', $server->id)
                ->update([
                    'cached_location' => $locationAttrs['long'] ?? $locationAttrs['short'] ?? null,
                    'cached_egg' => $eggAttrs['name'] ?? null,
                    'cached_nest' => $nestAttrs['name'] ?? null,
                    'cached_node' => $nodeAttrs['name'] ?? null,
                    'cache_updated_at' => now()
                ]);
        } catch (Exception $e) {
            Log::warning('Failed to save server cache to database', [
                'server_id' => $server->id,
                'error' => $e->getMessage()
            ]);
        }
    }

    // ОЧИСТКА КЕША
    private function clearUserCache(int $userId): void
    {
        Cache::forget(self::USER_SERVERS_CACHE_PREFIX . $userId);
        Cache::forget("user_{$userId}_product_*");
        
        // Очищаем статический кеш только при необходимости
        if (rand(1, 100) === 1) { // 1% вероятность
            Cache::forget('server_create_data_v2');
            Cache::forget('nests_optimized');
            Cache::forget('locations_optimized');
            Cache::forget('eggs_optimized');
            Cache::forget('products_optimized');
        }
    }

    // МЕТОД ДЛЯ ПРИНУДИТЕЛЬНОГО ОБНОВЛЕНИЯ КЕША
    public function refreshServerCache(Server $server): RedirectResponse
    {
        if ($server->user_id !== Auth::id()) {
            return back()->with('error', __('This is not your Server!'));
        }

        // Очищаем кеш сервера
        if ($server->pterodactyl_id) {
            Cache::forget(self::SERVER_INFO_CACHE_PREFIX . $server->pterodactyl_id);
        }
        
        // Очищаем кеш пользователя
        $this->clearUserCache($server->user_id);

        return back()->with('success', __('Server information refreshed'));
    }

    private function createServer(Request $request): ?Server
    {
        $product = Product::findOrFail($request->input('product'));
        $egg = $product->eggs()->findOrFail($request->input('egg'));
        $node = $this->findAvailableNode($request->input('location'), $product);

        if (!$node) return null;

        $server = $request->user()->servers()->create([
            'name' => $request->input('name'),
            'product_id' => $product->id,
            'last_billed' => Carbon::now()
        ]);

        $allocationId = $this->pterodactyl->getFreeAllocationId($node);
        if (!$allocationId) {
            Log::error('No AllocationID found.', [
                'server_id' => $server->id,
                'node_id' => $node->id,
            ]);
            $server->delete();
            return null;
        }

        $response = $this->pterodactyl->createServer($server, $egg, $allocationId, $request->input('egg_variables'));
        if ($response->failed()) {
            Log::error('Failed to create server on Pterodactyl', [
                'server_id' => $server->id,
                'status' => $response->status(),
                'error' => $response->json()
            ]);
            $server->delete();
            return null;
        }

        $serverAttributes = $response->json()['attributes'];
        $server->update([
            'pterodactyl_id' => $serverAttributes['id'],
            'identifier' => $serverAttributes['identifier']
        ]);

        return $server;
    }

    private function handlePostCreation(User $user, Server $server): void
    {
        $user->decrement('credits', $server->product->price);

        try {
            if ($this->discordSettings->role_on_purchase &&
                $user->discordUser &&
                $user->servers->count() >= 1
            ) {
                $user->discordUser->addOrRemoveRole(
                    'add',
                    $this->discordSettings->role_id_on_purchase
                );
            }
        } catch (Exception $e) {
            Log::debug('Discord role update failed: ' . $e->getMessage());
        }
    }

    public function destroy(Server $server): RedirectResponse
    {
        if ($server->user_id !== Auth::id()) {
            return back()->with('error', __('This is not your Server!'));
        }

        try {
            $serverInfo = $this->pterodactyl->getServerAttributes($server->pterodactyl_id);

            if (!$serverInfo) {
                throw new Exception("Server not found on Pterodactyl panel");
            }

            $this->handleServerDeletion($server);
            
            // Очищаем кеш после удаления
            $this->clearUserCache($server->user_id);

            return redirect()->route('servers.index')
                ->with('success', __('Server removed'));
        } catch (Exception $e) {
            Log::error('Server deletion failed', [
                'server_id' => $server->id,
                'pterodactyl_id' => $server->pterodactyl_id,
                'error' => $e->getMessage()
            ]);

            return redirect()->route('servers.index')
                ->with('error', __('Server removal failed: ') . $e->getMessage());
        }
    }

    private function handleServerDeletion(Server $server): void
    {
        if ($this->discordSettings->role_on_purchase) {
            $user = User::findOrFail($server->user_id);
            if ($user->discordUser && $user->servers->count() <= 1) {
                $user->discordUser->addOrRemoveRole(
                    'remove',
                    $this->discordSettings->role_id_on_purchase
                );
            }
        }

        $server->delete();
    }

    public function cancel(Server $server): RedirectResponse
    {
        if ($server->user_id !== Auth::id()) {
            return back()->with('error', __('This is not your Server!'));
        }

        try {
            $server->update(['canceled' => now()]);
            
            // Очищаем кеш после отмены
            $this->clearUserCache($server->user_id);
            
            return redirect()->route('servers.index')
                ->with('success', __('Server canceled'));
        } catch (Exception $e) {
            return redirect()->route('servers.index')
                ->with('error', __('Server cancellation failed: ') . $e->getMessage());
        }
    }

    public function show(Server $server): \Illuminate\View\View
    {
        if ($server->user_id !== Auth::id()) {
            return back()->with('error', __('This is not your Server!'));
        }

        $serverAttributes = $this->pterodactyl->getServerAttributes($server->pterodactyl_id);
        $upgradeOptions = $this->getUpgradeOptions($server, $serverAttributes);
        return view('servers.settings')->with([
            'server' => $server,
            'serverAttributes' => $serverAttributes,
            'products' => $upgradeOptions,
            'server_enable_upgrade' => $this->serverSettings->enable_upgrade,
            'credits_display_name' => $this->generalSettings->credits_display_name,
            'location_description_enabled' => $this->serverSettings->location_description_enabled,
        ]);
    }

    private function getUpgradeOptions(Server $server, array $serverInfo): \Illuminate\Database\Eloquent\Collection
    {
        $currentProduct = Product::find($server->product_id);
        $nodeId = $serverInfo['relationships']['node']['attributes']['id'];
        $pteroNode = $this->pterodactyl->getNode($nodeId);
        $currentEgg = $serverInfo['egg'];

        return Product::orderBy('created_at')
            ->with('nodes')->with('eggs')
            ->whereHas('nodes', function (Builder $builder) use ($nodeId) {
                $builder->where('id', $nodeId);
            })
            ->whereHas('eggs', function (Builder $builder) use ($currentEgg) {
                $builder->where('id', $currentEgg);
            })
            ->get()
            ->map(function ($product) use ($currentProduct, $pteroNode) {
                $product->eggs = $product->eggs->pluck('name')->toArray();

                $memoryDiff = $product->memory - $currentProduct->memory;
                $diskDiff = $product->disk - $currentProduct->disk;

                $maxMemory = ($pteroNode['memory'] * ($pteroNode['memory_overallocate'] + 100) / 100);
                $maxDisk = ($pteroNode['disk'] * ($pteroNode['disk_overallocate'] + 100) / 100);

                if ($memoryDiff > $maxMemory - $pteroNode['allocated_resources']['memory'] ||
                    $diskDiff > $maxDisk - $pteroNode['allocated_resources']['disk']) {
                    $product->doesNotFit = true;
                }

                return $product;
            });
    }

    public function upgrade(Server $server, Request $request): RedirectResponse
    {
        $this->checkPermission(self::UPGRADE_PERMISSION);

        if ($server->user_id !== Auth::id()) {
            return redirect()->route('servers.index')
                ->with('error', __('This is not your Server!'));
        }

        if (!$request->has('product_upgrade')) {
            return redirect()->route('servers.show', ['server' => $server->id])
                ->with('error', __('No product selected for upgrade'));
        }

        $user = Auth::user();
        $oldProduct = Product::find($server->product->id);
        $newProduct = Product::find($request->product_upgrade);

        if (!$newProduct) {
            return redirect()->route('servers.show', ['server' => $server->id])
                ->with('error', __('Selected product not found'));
        }

        if (!$this->validateUpgrade($server, $oldProduct, $newProduct)) {
            return redirect()->route('servers.show', ['server' => $server->id])
                ->with('error', __('Insufficient resources or credits for upgrade'));
        }

        try {
            $this->processUpgrade($server, $oldProduct, $newProduct, $user);
            
            // Очищаем кеш после апгрейда
            $this->clearUserCache($server->user_id);
            
            return redirect()->route('servers.show', ['server' => $server->id])
                ->with('success', __('Server Successfully Upgraded'));
        } catch (Exception $e) {
            Log::error('Server upgrade failed', [
                'server_id' => $server->id,
                'old_product' => $oldProduct->id,
                'new_product' => $newProduct->id,
                'error' => $e->getMessage()
            ]);

            return redirect()->route('servers.show', ['server' => $server->id])
                ->with('error', __('Upgrade failed: ') . $e->getMessage());
        }
    }

    private function validateUpgrade(Server $server, Product $oldProduct, Product $newProduct): bool
    {
        $user = Auth::user();
        if (!$server->product) {
            return false;
        }

        $serverInfo = $this->pterodactyl->getServerAttributes($server->pterodactyl_id);
        if (!$serverInfo) {
            return false;
        }

        $nodeId = $serverInfo['relationships']['node']['attributes']['id'];
        $node = Node::findOrFail($nodeId);

        // Check node resources
        $requireMemory = $newProduct->memory - $oldProduct->memory;
        $requireDisk = $newProduct->disk - $oldProduct->disk;
        if (!$this->pterodactyl->checkNodeResources($node, $requireMemory, $requireDisk)) {
            return false;
        }

        // ИСПРАВЛЕНИЕ: Более точная проверка баланса с учетом возврата
        $refundAmount = $this->calculateRefund($server, $oldProduct);
        $upgradePrice = $newProduct->price - $refundAmount;
        
        // Убеждаемся что баланс не уйдет в минус после апгрейда
        if ($user->credits < $upgradePrice) {
            return false;
        }

        return true;
    }

    private function processUpgrade(Server $server, Product $oldProduct, Product $newProduct, User $user): void
    {
        $server->allocation = $this->pterodactyl->getServerAttributes($server->pterodactyl_id)['allocation'];

        $response = $this->pterodactyl->updateServer($server, $newProduct);
        if ($response->failed()) {
            throw new Exception("Failed to update server on Pterodactyl");
        }

        $restartResponse = $this->pterodactyl->powerAction($server, 'restart');
        if ($restartResponse->failed()) {
            throw new Exception('Could not restart the server: ' . $restartResponse->json()['errors'][0]['detail']);
        }

        // Calculate refund
        $refund = $this->calculateRefund($server, $oldProduct);
        if ($refund > 0) {
            $user->increment('credits', $refund);
        }

        // Update server
        unset($server->allocation);
        $server->update([
            'product_id' => $newProduct->id,
            'updated_at' => now(),
            'last_billed' => now(),
            'canceled' => null,
        ]);

        // Charge for new product
        $user->decrement('credits', $newProduct->price);
    }

    private function calculateRefund(Server $server, Product $oldProduct): float
    {
        $billingPeriod = $oldProduct->billing_period;
        $billingPeriodSeconds = self::BILLING_PERIODS[$billingPeriod];
        $timeUsed = now()->diffInSeconds($server->last_billed, true);

        return $oldProduct->price - ($oldProduct->price * ($timeUsed / $billingPeriodSeconds));
    }

    private function findAvailableNode(string $locationId, Product $product): ?Node
    {
        $nodes = Node::where('location_id', $locationId)
            ->whereHas('products', fn($q) => $q->where('product_id', $product->id))
            ->get();

        $availableNodes = $nodes->reject(function ($node) use ($product) {
            return !$this->pterodactyl->checkNodeResources($node, $product->memory, $product->disk);
        });

        return $availableNodes->isEmpty() ? null : $availableNodes->first();
    }

    public function validateDeploymentVariables(Request $request)
    {
        $variables = $request->input('variables');

        $errors = [];

        foreach ($variables as $variable) {
            $rules = $variable['rules'];
            $envVariable = $variable['env_variable'];
            $filledValue = $variable['filled_value'];

            $validator = Validator::make(
                [$envVariable => $filledValue],
                [$envVariable => $rules]
            );

            $validator->setAttributeNames([
                $envVariable => $variable['name'],
            ]);

            if ($validator->fails()) {
                $errors[$envVariable] = $validator->errors()->get($envVariable);
            }
        }

        if (!empty($errors)) {
            return response()->json([
                'errors' => $errors
            ], 422);
        }

        return response()->json([
            'success' => true,
            'variables' => $variables,
        ]);
    }

    // API для получения продуктов через AJAX (для еще большей скорости)
    public function getProductsApi(Request $request)
    {
        $locationId = $request->input('location_id');
        $eggId = $request->input('egg_id');

        $products = Cache::remember("products_location_{$locationId}_egg_{$eggId}", self::STATIC_CACHE_TTL, function () use ($locationId, $eggId) {
            return DB::table('products')
                ->join('node_product', 'products.id', '=', 'node_product.product_id')
                ->join('nodes', 'node_product.node_id', '=', 'nodes.id')
                ->join('egg_product', 'products.id', '=', 'egg_product.product_id')
                ->where('products.disabled', false)
                ->where('nodes.location_id', $locationId)
                ->where('egg_product.egg_id', $eggId)
                ->select('products.*')
                ->distinct()
                ->get();
        });

        return response()->json($products);
    }

    // Добавьте индексы в БД для оптимизации
    public function addDatabaseIndexes()
    {
        try {
            DB::statement('CREATE INDEX IF NOT EXISTS idx_servers_user_product ON servers(user_id, product_id)');
            DB::statement('CREATE INDEX IF NOT EXISTS idx_servers_pterodactyl_id ON servers(pterodactyl_id)');
            DB::statement('CREATE INDEX IF NOT EXISTS idx_products_disabled ON products(disabled)');
            DB::statement('CREATE INDEX IF NOT EXISTS idx_servers_deleted_at ON servers(deleted_at)');
            DB::statement('CREATE INDEX IF NOT EXISTS idx_node_product ON node_product(node_id, product_id)');
            DB::statement('CREATE INDEX IF NOT EXISTS idx_egg_product ON egg_product(egg_id, product_id)');
        } catch (Exception $e) {
            Log::warning('Failed to create database indexes', ['error' => $e->getMessage()]);
        }
    }

    // Очистка всего кеша (для админов)
    public function clearAllCache()
    {
        Cache::flush();
        return back()->with('success', 'All cache cleared successfully!');
    }
}
